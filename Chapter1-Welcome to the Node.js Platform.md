## Reactor模式
`Reactor模式`是`Node.js`异步编程的核心模块，其核心概念是：`单线程`、`非阻塞I/O`，通过下列例子可以看到`Reactor模式`在`Node.js`平台的体现。

### I/O是缓慢的
在计算机的基本操作中，输入输出肯定是最慢的。访问内存的速度是纳秒级(`10e-9 s`)，同时访问磁盘上的数据或访问网络上的数据则更慢，是毫秒级(`10e-3 s`)。内存的传输速度一般认为是`GB/s`来计算，然而磁盘或网络的访问速度则比较慢，一般是`MB/s`。虽然对于`CPU`而言，`I/O`操作的资源消耗并不算大，但是在发送`I/O`请求和操作完成之间总会存在时间延迟。除此之外，我们还必须考虑人为因素，通常情况下，应用程序的输入是人为产生的，例如：按钮的点击、即时聊天工具的信息发送。因此，输入输出的速度并不因网络和磁盘访问速率慢造成的，还有多方面的因素。

### 阻塞I/O
在一个`阻塞I/O`模型的进程中，`I/O`请求会阻塞之后代码块的运行。在`I/O`请求操作完成之前，线程会有一段不定长的时间浪费。（它可能是毫秒级的，但甚至有可能是分钟级的，如用户按着一个按键不放的情况）。以下例子就是一个`阻塞I/O`模型。

```javascript
// 直到请求完成，数据可用，线程都是阻塞的
data = socket.read();
// 请求完成，数据可用
print(data);
```

我们知道，`阻塞I/O`的服务器模型并不能在一个线程中处理多个连接，每次`I/O`都会阻塞其它连接的处理。出于这个原因，对于每个需要处理的并发连接，传统的web服务器的处理方式是新开一个新的进程或线程（或者从线程池中重用一个进程）。这样，当一个线程因 `I/O`操作被阻塞时，它并不会影响另一个线程的可用性，因为他们是在彼此独立的线程中处理的。

通过下面这张图：

![](http://oczira72b.bkt.clouddn.com/17-9-14/68827012.jpg)

通过上面的图片我们可以看到每个线程都有一段时间处于空闲等待状态，等待从关联连接接收新数据。如果所有种类的`I/O`操作都会阻塞后续请求。例如，连接数据库和访问文件系统，现在我们能很快知晓一个线程需要因等待`I/O`操作的结果等待许多时间。不幸的是，一个线程所持有的`CPU`资源并不廉价，它需要消耗内存、造成`CPU`上下文切换，因此，长期占有`CPU`而大部分时间并没有使用的线程，在资源利用率上考虑，并不是高效的选择。

### 非阻塞I/O
除`阻塞I/O`之外，大部分现代的操作系统支持另外一种访问资源的机制，即`非阻塞I/O`。在这种机制下，后续代码块不会等到`I/O`请求数据的返回之后再执行。如果当前时刻所有数据都不可用，函数会先返回预先定义的常量值(如`undefined`)，表明当前时刻暂无数据可用。

例如，在`Unix`操作系统中，`fcntl()`函数操作一个已存在的文件描述符，改变其操作模式为`非阻塞I/O`(通过`O_NONBLOCK`状态字)。一旦资源是非阻塞模式，如果读取文件操作没有可读取的数据,或者如果写文件操作被阻塞,读操作或写操作返回`-1`和`EAGAIN`错误。

`非阻塞I/O`最基本的模式是通过轮询获取数据，这也叫做**忙-等模型**。看下面这个例子，通过`非阻塞I/O`和轮询机制获取`I/O`的结果。

```javascript
resources = [socketA, socketB, pipeA];
while(!resources.isEmpty()) {
  for (i = 0; i < resources.length; i++) {
    resource = resources[i];
    // 进行读操作
    let data = resource.read();
    if (data === NO_DATA_AVAILABLE) {
      // 此时还没有数据
      continue;
    }
    if (data === RESOURCE_CLOSED) {
      // 资源被释放，从队列中移除该链接
      resources.remove(i);
    } else {
      consumeData(data);
    }
  }
}
```

我们可以看到，通过这个简单的技术，已经可以在一个线程中处理不同的资源了，但依然不是高效的。事实上，在前面的例子中，用于迭代资源的循环只会消耗宝贵的`CPU`，而这些资源的浪费比起`阻塞I/O`反而更不可接受，轮询算法通常浪费大量`CPU`时间。