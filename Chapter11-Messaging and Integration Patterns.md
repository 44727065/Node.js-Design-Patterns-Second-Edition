# Messaging and Integration Patterns
如果应用程序涉及到分布式系统。在前一章中，我们学习了如何如何通过使用一些简单的架构模式来集成大量的服务，将其分割到多个机器上。为了使其正常工作，所有机器都必须以某种方式进行交互，因此必须整合它们的交互方式。

有两种主要的技术来集成分布式应用程序：一种是使用共享存储，另一种是使用消息在系统节点上传播数据，这里涉及事件和命令模式。后者在扩展分布式系统时确实有用，这也是后一种方式被广泛运用的原因。

消息被用于软件系统的每一层。我们交换消息以在互联网上进行通信，我们可以使用消息将信息发送到使用管道的其他进程，我们可以使用应用程序中的消息作为直接函数调用（命令模式）的替代方法，甚至也可以使用消息与硬件直接交互。用作在组件和系统之间交换信息的方式的任何离散和结构化数据都可以看作是一条消息。但是，在处理分布式体系结构时，消息传递系统用于描述旨在促进网络信息交换的特定类别的解决方案，模式或者说体系结构。

正如我们将看到的，有几种特征表征这些类型的系统。我们可以选择使用代理模式或点对点结构，我们可以使用请求/回复模式或单向通信，也可以使用队列来更可靠地传递消息；消息整合模式的使用范围非常广泛。本章从`Node.js`及其生态系统的角度探讨了这些众所周知的模式中最重要的模式。

总而言之，在本章中，我们将学习以下主题：

* 消息传递系统的基本原理
* 发布/订阅模式
* 管道和任务分配模式
* 请求/回复模式

## 消息传递系统的基本原理
在谈论消息和消息传递系统时，需要考虑四个基本要素，如下：
* 通信的方向，可以是单向的，也可以是双向的
* 消息的目的地，这也决定了消息的内容
* 消息的时间，这决定了消息是否可以被立即发送和接收（同步），也可以在将来接收（异步）
* 信息的传递方式，直接传递或通过一个中介者进行传递

在接下来的部分中，我们将把这些方面正式化，以便为我们稍后的讨论奠定基础。

### 单向通信和请求/回复模式
消息传递系统中最基本的方面是通信的传递方向，这个方向通常也表示了这条消息的含义。

最简单的消息传递模式是消息从源到目的地单向推送; 这是一个简单的情况，并不需要太多解释：

![](http://oczira72b.bkt.clouddn.com/18-3-6/85270514.jpg)

单向通信的一个典型例子是使用`WebSockets`向连接的浏览器或`Web`服务器发送消息的电子邮件，或将任务分配给一组工作人员的系统。

然而，请求/回复模式比单向通信更受欢迎；一个典型的例子就是调用Web服务。下图显示了这个简单且众所周知的场景：

![](http://oczira72b.bkt.clouddn.com/18-3-6/77969595.jpg)

请求/回复模式可能看起来是一个简单的模式; 但是，当通信异步或涉及多个节点时，我们将看到它变得更加复杂。看看下图中的例子：

![](http://oczira72b.bkt.clouddn.com/18-3-6/78681245.jpg)

通过上图所示的设置，我们可以理解一些请求/回复模式的复杂性。如果我们考虑任何两个节点之间的通信方向，我们可以肯定地说它是单向的。但是，从全局角度来看，发起者发送一个请求，然后接收一个关联的响应，即使来自不同的节点。在这些情况下，真正区分请求/响应模式与单向消息传递模式的区别在于请求和响应之间的关系，它保存在发起者中。回复通常在请求的相同上下文中处理。

### 消息类型
一条消息本质上是连接不同软件组件的一种方式，这样做的原因有很多：这可能是因为我们想要获得由另一个系统或组件持有的某些信息，或远程执行某项操作，或向某个组件通知某操作刚刚发生。消息内容也会因通信原因而异。 一般来说，我们可以根据消息的目的来确定三种类型的消息：

* 命令消息
* 事件消息
* 文档消息

#### 命令消息
命令消息对我们来说已经很熟悉；它本质上是一个序列化的`command`对象，正如我们在`Chapter 6-Design Patterns`中所描述的那样。 这种类型的消息的目的是触发`recevier`上的动作或任务的执行。为了做到这一点，我们的信息必须包含运行任务的基本信息，这通常是操作的名称和执行时提供的参数列表。 命令消息可用于实现远程过程调用（`RPC`）系统，分布式计算或更简单地用于请求某些数据。`RESTful HTTP`调用是命令消息的简单示例; 每个`HTTP`请求都有一个特定的含义，并与一个精确的操作相关联：例如`GET`表示检索资源；`POST`表示创建一个新的资源；`PUT`表示更新一个资源；`DELETE`表示删除一个资源。

#### 事件消息
事件消息用于通知另一个组件发生了某些事件。它通常包含事件的类型，有时还包含一些细节，如`context`，`subject`或`actor`。 在`Web`开发中，当使用长轮询或`WebSocket`接收来自服务器的刚刚发生的事件的通知时，我们在浏览器中使用事件消息，例如数据的变化导致一个时间的发生。事件的使用是分布式应用程序中非常重要的机制，因为它使我们能够将系统的所有节点保持在同一状态上。

#### 文档消息
文档消息主要用于在组件和机器之间传输数据。区分文档消息和命令消息（可能还包含数据）的主要特点是该消息不包含告诉接收方如何处理数据的任何信息。另一方面，与事件消息的主要区别主要是缺少与特定事件的关联。通常，对命令消息的回复是文档消息，因为它们通常只包含请求的数据或操作的结果。

### 异步消息传递和队列
作为`Node.js`开发人员，我们应该已经知道执行异步操作的优势。对于消息和通信而言，这是一回事。

我们可以将同步通信与电话进行比较：两个对等设备必须同时连接到同一个通道，并且它们应该实时交换消息。通常情况下，如果我们想打电话给其他人，我们可能需要另一部手机或关闭正在进行的通信以便开始新的通话。

异步通信类似于`SMS`：它不要求收件人在我们发送邮件时连接到网络，我们可能会立即收到回复或者收到未知延迟后的回复，或者我们可能根本没有收到回复。我们可能会将多个`SMS`一个接一个地发送给多个收件人，并以任何顺序收到他们的回复（如果有）。简而言之，我们使用更少的资源可以获得更好的并行性。

异步通信的另一个重要优点是可以将消息存储并尽快或稍后发送。当接收器太忙而无法处理新消息或我们希望保证传送时，这可能很有用。在消息传递系统中，这可以使用消息队列实现，该消息队列调解发送者和接收者之间的通信，在将消息传递到其目标之前存储任何消息，如下图所示：

![](http://oczira72b.bkt.clouddn.com/18-3-6/54869165.jpg)

如果出于任何原因接收机崩溃，与网络断开连接或速度变慢，则消息会在队列中累积并在接收机联机并且完全正常工作时才可以让发送者继续请求并调度。队列可以位于发送者中，也可以在发送者和接收者之间分开，或者存储在充当通信中间件的专用外部系统中。

### 点对点或基于代理的消息传递
消息可以以对等方式直接传送给接收方，也可以通过称为消息代理的集中式中介系统传送。代理的主要作用是将发件人的信息接收者分离出来。下图显示了两种方法之间的架构差异：

![](http://oczira72b.bkt.clouddn.com/18-3-6/78511743.jpg)

在对等体系结构中，每个节点都直接负责将消息传递给接收方。这意味着节点必须知道接收方的地址和端口，他们必须就协议和消息格式达成一致。代理从等式中消除了这些复杂性：每个节点都可以完全独立，并且可以与未定义数量的对等进行通信，而无需直接了解其详细信息。 代理还可以充当不同通信协议之间的桥梁，例如，[RabbitMQ broker](http://www.rabbitmq.com)支持高级消息队列协议（`AMQP`），消息队列遥测传输（`MQTT`）和 简单/流式文本定向消息协议（`STOMP`），支持不同消息协议的多个应用程序进行交互。

> [MQTT](http://mqtt.org)是一种轻量级消息传递协议，专为机器间通信（物联网）设计。 [AMQP](http://www.amqp.org)是一个更复杂的协议，旨在成为专有消息中间件的开源替代品。[STOMP](http://stomp.github.io)是一个轻量级的基于文本的协议，来自`HTTP school of design`。 这三个都是应用层协议，并且基于`TCP / IP`。

除了解耦和互操作性外，代理还可以提供更多高级功能，如持久队列，路由，消息转换和监控，而不提及许多代理支持的广泛的消息传递模式。当然，没有任何东西可以阻止我们使用对等体系结构实现所有这些功能，但不幸的是，还需要付出更多努力。尽管如此，避免使用代理的原因可能有所不同：

* 代理可能发生故障
* 代理必须扩展，而在对等体系结构中，我们只需要扩展单个节点
* 在没有代理的情况下交换消息可以大大减少传输的延迟

如果我们想要实现一个对等消息传递系统，我们也拥有更多的灵活性和能力，因为我们不受任何特定技术，协议或体系结构的约束。 [ØMQ](http://zeromq.org)是一个构建消息传递系统的库，其流行性很好地证明了我们可以通过构建定制的对等或混合体系结构获得灵活性。

## 发布/订阅模式
发布/订阅（通常缩写为`pub / sub`）可能是最着名的单向消息传递模式。我们应该已经熟悉它了，因为它不过是一个分布式的观察者模式。就观察者而言，我们有一组用户注册他们对接收特定类别的消息的兴趣。另一方面，发布者产生分布在所有相关用户中的消息。下图显示了发布/订阅模式的两个主要变体，第一个是点对点，第二个使用代理来调解通信：

![](http://oczira72b.bkt.clouddn.com/18-3-6/30922433.jpg)

让pub / sub如此特别的是，发布者不知道邮件的收件人是谁。正如我们所说的那样，用户必须注册它的监听器才能收到特定的消息，从而允许发布者与未知数量的接收者一起工作。换句话说，`pub / sub`模式的两边是松散耦合的，这使得它成为一个理想模式来集成不断发展的分布式系统的节点。

代理的存在进一步改善了系统节点之间的解耦，因为订阅者仅与代理交互，不知道哪个节点是消息发布者。正如我们稍后将看到的，代理还可以提供消息队列系统，即使在节点之间存在连接问题的情况下也可以实现可靠的传送。

现在，让我们以一个示例来演示这种模式。

### 构建一个简单的实时聊天应用程序
为了展示`pub / sub`模式如何帮助我们集成分布式体系结构的实例，现在我们将使用纯`WebSockets`构建一个非常基本的实时聊天应用程序。然后，我们将尝试通过运行多个实例并使用消息传递系统进行通信来扩展它。

#### 实现服务器端
现在，让我们一次一步。 首先构建我们的聊天应用程序; 为此，我们将依赖[ws](https://npmjs.org/package/ws)，它是`Node.js`的纯`WebSocket`实现。我们知道，在`Node.js`中实现实时应用程序非常简单，我们的代码将证实这一假设。然后让我们创建聊天的服务器端; 其内容如下（在`app.js`文件中）：

```javascript
const WebSocketServer = require('ws').Server;

// 静态的文件服务器
const server = require('http').createServer( //[1]
  require('ecstatic')({
    root: `${__dirname}/www`
  })
);

const wss = new WebSocketServer({
  server: server
}); //[2]
wss.on('connection', ws => {
  console.log('Client connected');
  ws.on('message', msg => { //[3]
    console.log(`Message: ${msg}`);
    broadcast(msg);
  });
});

function broadcast(msg) { //[4]
  wss.clients.forEach(client => {
    client.send(msg);
  });
}

server.listen(process.argv[2] || 8080);
```

这就是我们需要在服务器上实现聊天应用程序的全部内容。这是它的工作方式：

1. 我们首先创建一个`HTTP`服务器并附上名为`ecstatic`的中间件（ https://npmjs.org/package/ecstatic ）来提供静态文件。 这需要为我们的应用程序（`JavaScript`和`CSS`）的客户端资源提供服务。
2. 我们创建一个`WebSocket`服务器的新实例，并将其附加到我们现有的`HTTP`服务器上。然后，我们通过附加连接事件的事件侦听器来开始监听传入的`WebSocket`连接。
3. 每当新客户端连接到我们的服务器时，我们就开始监听收到的消息。当新消息到达时，我们将它广播给所有连接的客户端
4. `broadcast()`函数是对所有连接客户端进行广播，`send()`函数在其中的每一个客户端上被调用。

这是`Node.js`的魔力！ 当然，我们实现的服务器的功能非常少，仅仅实现了基本的功能，但正如我们将看到的，它能够工作。

#### 实现客户端
接下来，是时候实施我们聊天的客户端了;这也是一个非常小而简单的代码片段，基本上是一个包含一些基本`JavaScript`代码的最少的`HTML`页面。让我们在一个名为`www/index.html`的文件中创建这个页面，如下所示：

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      var ws = new WebSocket('ws://' + window.document.location.host);
      ws.onmessage = function(message) {
        var msgDiv = document.createElement('div');
        msgDiv.innerHTML = message.data;
        document.getElementById('messages').appendChild(msgDiv);
      };
      
      function sendMessage() {
        var message = document.getElementById('msgBox').value;
        ws.send(message);
      }
    </script>
  </head>
  <body>
    Messages:
    <div id='messages'></div>
    <input type='text' placeholder='Send a message' id='msgBox'>
    <input type='button' onclick='sendMessage()' value='Send'>
  </body>
</html>
```

我们创建的HTML页面并不需要太多解释; 它只是一个简单的`Web`页面。 我们使用本地`WebSocket`对象初始化与`Node.js`服务器的连接，然后开始监听来自服务器的消息，并在它们到达时将它们显示在新的`div`元素中。相反，我们使用简单的文本框和按钮来发送消息。

在停止或重新启动聊天服务器时，`WebSocket`连接将关闭，并且不会自动重新连接（如果要实现此则需要使用高级库，例如`Socket.io`）。 这意味着在服务器重新启动后重新刷新浏览器以重新建立连接（或实现重新连接机制，这里我们不会介绍）。

#### 运行和扩展聊天应用程序
我们可以尝试立即运行应用程序; 只需使用以下命令启动服务器即可：

```bash
node app 8080
```

> 要运行这个demo，您需要支持本机`WebSocket`的最新浏览器。这里有一个兼容的浏览器列表： http://caniuse.com/#feat=websockets 

打开浏览器，访问 http://localhost:8080 ：

![](http://oczira72b.bkt.clouddn.com/18-3-6/56502781.jpg)

我们现在要展示的是当我们尝试通过启动多个实例来扩展应用程序时发生的情况。让我们尝试这样做，让我们在另一个端口上启动另一台服务器：

```bash
node app 8081
```

缩放我们的聊天应用程序的理想结果应该是连接到两个不同服务器的两个客户端应该能够交换聊天消息。不幸的是，这不如我们所愿。 我们可以通过打开另一个浏览器选项卡来尝试打开 http://localhost:8081 。

在一个实例上发送聊天消息时，我们在本地广播一条消息，仅将其分发给连接到该特定服务器的客户端。实际上，两台服务器不会互相通话。 我们需要整合它们。

![](http://oczira72b.bkt.clouddn.com/18-3-6/27320700.jpg)

在实际的应用程序中，我们将使用负载平衡器来分配实例中的负载，但对于此演示，我们不会使用它。这使我们能够以确定性的方式访问每台服务器，以验证它与其它实例交互的方式。

### 使用Redis作为消息代理
我们通过引入[Redis](http://redis.io)开始分析最重要的`pub / sub`实现，这是一个非常快速和灵活的键/值存储，也被许多人定义为数据结构服务器。

Redis比消息代理更像是一个数据库；然而，在其众多功能中，有一对专门用于实现集中式发布/订阅模式的命令。
当然，与更先进的面向消息的中间件相比，这种实现非常简单和基本，但这是其受欢迎的主要原因之一。通常，实际上，`Redis`已经在现有基础架构中广泛使用，例如，作为缓存服务器或会话存储；它的速度和灵活性使其成为在分布式系统中共享数据的非常流行的选择。因此，只要项目中出现对发布/订阅代理的需求，最简单直接的选择就是重用`Redis`本身，避免安装和维护专用的消息代理。让我们以一个例子来展示它的功能。

> 这个例子需要安装`Redis`，监听它的默认端口。你可以在这里查看： https://redis.io/topics/quickstart 

我们计划使用`Redis`来作为聊天服务器的消息代理。每个实例都将从其客户端接收到的任何消息发布给代理，并同时订阅来自其他服务器实例的消息。正如我们所看到的，我们架构中的每个服务器都是订阅者和发布者。下图显示了我们想要获得的体系结构的表示形式：

![](http://oczira72b.bkt.clouddn.com/18-3-6/56153519.jpg)

通过查看上图，我们可以总结一条消息的经历如下：

1. 将消息输入到网页的文本框中并发送到聊天服务器的连接实例。
2. 邮件然后发布给代理。
3. 代理将消息分派给所有订阅者，在我们的体系结构中，所有订阅者都是聊天服务器的实例。
4. 在每种情况下，都会将消息分发给所有连接的客户端。

`Redis`允许发布和订阅由字符串标识的频道，例如`chat.nodejs`。它还允许我们使用`glob`风格的模式来定义可能匹配多个频道的订阅，例如`chat.*`。

我们在实践中看看它是如何工作的。让我们通过添加发布/订阅逻辑来修改服务器代码：

```javascript
const WebSocketServer = require('ws').Server;
const redis = require("redis");
const redisSub = redis.createClient();
const redisPub = redis.createClient();

// 静态文件服务器
const server = require('http').createServer(
  require('ecstatic')({root: `${__dirname}/www`})
);

const wss = new WebSocketServer({server: server});
wss.on('connection', ws => {
  console.log('Client connected');
  ws.on('message', msg => {
    console.log(`Message: ${msg}`);
    redisPub.publish('chat_messages', msg);
  });
});

redisSub.subscribe('chat_messages');
redisSub.on('message', (channel, msg) => {
  wss.clients.forEach((client) => {
    client.send(msg);
  });
});

server.listen(process.argv[2] || 8080);
```

我们对原始聊天服务器所做的更改在前面的代码中突出显示；下面来解释其工作原理：

