# Messaging and Integration Patterns
如果应用程序涉及到分布式系统。在前一章中，我们学习了如何如何通过使用一些简单的架构模式来集成大量的服务，将其分割到多个机器上。为了使其正常工作，所有机器都必须以某种方式进行交互，因此必须整合它们的交互方式。

有两种主要的技术来集成分布式应用程序：一种是使用共享存储，另一种是使用消息在系统节点上传播数据，这里涉及事件和命令模式。后者在扩展分布式系统时确实有用，这也是后一种方式被广泛运用的原因。

消息被用于软件系统的每一层。我们交换消息以在互联网上进行通信，我们可以使用消息将信息发送到使用管道的其他进程，我们可以使用应用程序中的消息作为直接函数调用（命令模式）的替代方法，甚至也可以使用消息与硬件直接交互。用作在组件和系统之间交换信息的方式的任何离散和结构化数据都可以看作是一条消息。但是，在处理分布式体系结构时，消息传递系统用于描述旨在促进网络信息交换的特定类别的解决方案，模式或者说体系结构。

正如我们将看到的，有几种特征表征这些类型的系统。我们可以选择使用代理模式或点对点结构，我们可以使用请求/回复模式或单向通信，也可以使用队列来更可靠地传递消息；消息整合模式的使用范围非常广泛。本章从`Node.js`及其生态系统的角度探讨了这些众所周知的模式中最重要的模式。

总而言之，在本章中，我们将学习以下主题：

* 消息传递系统的基本原理
* 发布/订阅模式
* 管道和任务分配模式
* 请求/回复模式

## 消息传递系统的基本原理
在谈论消息和消息传递系统时，需要考虑四个基本要素，如下：
* 通信的方向，可以是单向的，也可以是双向的
* 消息的目的地，这也决定了消息的内容
* 消息的时间，这决定了消息是否可以被立即发送和接收（同步），也可以在将来接收（异步）
* 信息的传递方式，直接传递或通过一个中介者进行传递

在接下来的部分中，我们将把这些方面正式化，以便为我们稍后的讨论奠定基础。

### 单向通信和请求/回复模式
消息传递系统中最基本的方面是通信的传递方向，这个方向通常也表示了这条消息的含义。

最简单的消息传递模式是消息从源到目的地单向推送; 这是一个简单的情况，并不需要太多解释：

![](http://oczira72b.bkt.clouddn.com/18-3-6/85270514.jpg)

单向通信的一个典型例子是使用`WebSockets`向连接的浏览器或`Web`服务器发送消息的电子邮件，或将任务分配给一组工作人员的系统。

然而，请求/回复模式比单向通信更受欢迎；一个典型的例子就是调用Web服务。下图显示了这个简单且众所周知的场景：

![](http://oczira72b.bkt.clouddn.com/18-3-6/77969595.jpg)

请求/回复模式可能看起来是一个简单的模式; 但是，当通信异步或涉及多个节点时，我们将看到它变得更加复杂。看看下图中的例子：

![](http://oczira72b.bkt.clouddn.com/18-3-6/78681245.jpg)

通过上图所示的设置，我们可以理解一些请求/回复模式的复杂性。如果我们考虑任何两个节点之间的通信方向，我们可以肯定地说它是单向的。但是，从全局角度来看，发起者发送一个请求，然后接收一个关联的响应，即使来自不同的节点。在这些情况下，真正区分请求/响应模式与单向消息传递模式的区别在于请求和响应之间的关系，它保存在发起者中。回复通常在请求的相同上下文中处理。

### 消息类型
一条消息本质上是连接不同软件组件的一种方式，这样做的原因有很多：这可能是因为我们想要获得由另一个系统或组件持有的某些信息，或远程执行某项操作，或向某个组件通知某操作刚刚发生。消息内容也会因通信原因而异。 一般来说，我们可以根据消息的目的来确定三种类型的消息：

* 命令消息
* 事件消息
* 文档消息

#### 命令消息
命令消息对我们来说已经很熟悉；它本质上是一个序列化的`command`对象，正如我们在`Chapter 6-Design Patterns`中所描述的那样。 这种类型的消息的目的是触发`recevier`上的动作或任务的执行。为了做到这一点，我们的信息必须包含运行任务的基本信息，这通常是操作的名称和执行时提供的参数列表。 命令消息可用于实现远程过程调用（`RPC`）系统，分布式计算或更简单地用于请求某些数据。`RESTful HTTP`调用是命令消息的简单示例; 每个`HTTP`请求都有一个特定的含义，并与一个精确的操作相关联：例如`GET`表示检索资源；`POST`表示创建一个新的资源；`PUT`表示更新一个资源；`DELETE`表示删除一个资源。

#### 事件消息
事件消息用于通知另一个组件发生了某些事件。它通常包含事件的类型，有时还包含一些细节，如`context`，`subject`或`actor`。 在`Web`开发中，当使用长轮询或`WebSocket`接收来自服务器的刚刚发生的事件的通知时，我们在浏览器中使用事件消息，例如数据的变化导致一个时间的发生。事件的使用是分布式应用程序中非常重要的机制，因为它使我们能够将系统的所有节点保持在同一状态上。

#### 文档消息
文档消息主要用于在组件和机器之间传输数据。区分文档消息和命令消息（可能还包含数据）的主要特点是该消息不包含告诉接收方如何处理数据的任何信息。另一方面，与事件消息的主要区别主要是缺少与特定事件的关联。通常，对命令消息的回复是文档消息，因为它们通常只包含请求的数据或操作的结果。

### 异步消息传递和队列
作为`Node.js`开发人员，我们应该已经知道执行异步操作的优势。对于消息和通信而言，这是一回事。

我们可以将同步通信与电话进行比较：两个对等设备必须同时连接到同一个通道，并且它们应该实时交换消息。通常情况下，如果我们想打电话给其他人，我们可能需要另一部手机或关闭正在进行的通信以便开始新的通话。

异步通信类似于`SMS`：它不要求收件人在我们发送邮件时连接到网络，我们可能会立即收到回复或者收到未知延迟后的回复，或者我们可能根本没有收到回复。我们可能会将多个`SMS`一个接一个地发送给多个收件人，并以任何顺序收到他们的回复（如果有）。简而言之，我们使用更少的资源可以获得更好的并行性。

异步通信的另一个重要优点是可以将消息存储并尽快或稍后发送。当接收器太忙而无法处理新消息或我们希望保证传送时，这可能很有用。在消息传递系统中，这可以使用消息队列实现，该消息队列调解发送者和接收者之间的通信，在将消息传递到其目标之前存储任何消息，如下图所示：

![](http://oczira72b.bkt.clouddn.com/18-3-6/54869165.jpg)

如果出于任何原因接收机崩溃，与网络断开连接或速度变慢，则消息会在队列中累积并在接收机联机并且完全正常工作时才可以让发送者继续请求并调度。队列可以位于发送者中，也可以在发送者和接收者之间分开，或者存储在充当通信中间件的专用外部系统中。

### 点对点或基于代理的消息传递
消息可以以对等方式直接传送给接收方，也可以通过称为消息代理的集中式中介系统传送。代理的主要作用是将发件人的信息接收者分离出来。下图显示了两种方法之间的架构差异：

![](http://oczira72b.bkt.clouddn.com/18-3-6/78511743.jpg)

在对等体系结构中，每个节点都直接负责将消息传递给接收方。这意味着节点必须知道接收方的地址和端口，他们必须就协议和消息格式达成一致。代理从等式中消除了这些复杂性：每个节点都可以完全独立，并且可以与未定义数量的对等进行通信，而无需直接了解其详细信息。 代理还可以充当不同通信协议之间的桥梁，例如，[RabbitMQ broker](http://www.rabbitmq.com)支持高级消息队列协议（`AMQP`），消息队列遥测传输（`MQTT`）和 简单/流式文本定向消息协议（`STOMP`），支持不同消息协议的多个应用程序进行交互。

> [MQTT](http://mqtt.org)是一种轻量级消息传递协议，专为机器间通信（物联网）设计。 [AMQP](http://www.amqp.org)是一个更复杂的协议，旨在成为专有消息中间件的开源替代品。[STOMP](http://stomp.github.io)是一个轻量级的基于文本的协议，来自`HTTP school of design`。 这三个都是应用层协议，并且基于`TCP / IP`。

除了解耦和互操作性外，代理还可以提供更多高级功能，如持久队列，路由，消息转换和监控，而不提及许多代理支持的广泛的消息传递模式。当然，没有任何东西可以阻止我们使用对等体系结构实现所有这些功能，但不幸的是，还需要付出更多努力。尽管如此，避免使用代理的原因可能有所不同：

* 代理可能发生故障
* 代理必须扩展，而在对等体系结构中，我们只需要扩展单个节点
* 在没有代理的情况下交换消息可以大大减少传输的延迟

如果我们想要实现一个对等消息传递系统，我们也拥有更多的灵活性和能力，因为我们不受任何特定技术，协议或体系结构的约束。 [ØMQ](http://zeromq.org)是一个构建消息传递系统的库，其流行性很好地证明了我们可以通过构建定制的对等或混合体系结构获得灵活性。

## 发布/订阅模式
发布/订阅（通常缩写为`pub / sub`）可能是最着名的单向消息传递模式。我们应该已经熟悉它了，因为它不过是一个分布式的观察者模式。就观察者而言，我们有一组用户注册他们对接收特定类别的消息的兴趣。另一方面，发布者产生分布在所有相关用户中的消息。下图显示了发布/订阅模式的两个主要变体，第一个是点对点，第二个使用代理来调解通信：

![](http://oczira72b.bkt.clouddn.com/18-3-6/30922433.jpg)

让pub / sub如此特别的是，发布者不知道邮件的收件人是谁。正如我们所说的那样，用户必须注册它的监听器才能收到特定的消息，从而允许发布者与未知数量的接收者一起工作。换句话说，`pub / sub`模式的两边是松散耦合的，这使得它成为一个理想模式来集成不断发展的分布式系统的节点。

代理的存在进一步改善了系统节点之间的解耦，因为订阅者仅与代理交互，不知道哪个节点是消息发布者。正如我们稍后将看到的，代理还可以提供消息队列系统，即使在节点之间存在连接问题的情况下也可以实现可靠的传送。

现在，让我们以一个示例来演示这种模式。

### 构建一个简单的实时聊天应用程序
为了展示`pub / sub`模式如何帮助我们集成分布式体系结构的实例，现在我们将使用纯`WebSockets`构建一个非常基本的实时聊天应用程序。然后，我们将尝试通过运行多个实例并使用消息传递系统进行通信来扩展它。

#### 实现服务器端
现在，让我们一次一步。 首先构建我们的聊天应用程序; 为此，我们将依赖[ws](https://npmjs.org/package/ws)，它是`Node.js`的纯`WebSocket`实现。我们知道，在`Node.js`中实现实时应用程序非常简单，我们的代码将证实这一假设。然后让我们创建聊天的服务器端; 其内容如下（在`app.js`文件中）：

```javascript
const WebSocketServer = require('ws').Server;

// 静态的文件服务器
const server = require('http').createServer( //[1]
  require('ecstatic')({
    root: `${__dirname}/www`
  })
);

const wss = new WebSocketServer({
  server: server
}); //[2]
wss.on('connection', ws => {
  console.log('Client connected');
  ws.on('message', msg => { //[3]
    console.log(`Message: ${msg}`);
    broadcast(msg);
  });
});

function broadcast(msg) { //[4]
  wss.clients.forEach(client => {
    client.send(msg);
  });
}

server.listen(process.argv[2] || 8080);
```

这就是我们需要在服务器上实现聊天应用程序的全部内容。这是它的工作方式：

1. 我们首先创建一个`HTTP`服务器并附上名为`ecstatic`的中间件（ https://npmjs.org/package/ecstatic ）来提供静态文件。 这需要为我们的应用程序（`JavaScript`和`CSS`）的客户端资源提供服务。
2. 我们创建一个`WebSocket`服务器的新实例，并将其附加到我们现有的`HTTP`服务器上。然后，我们通过附加连接事件的事件侦听器来开始监听传入的`WebSocket`连接。
3. 每当新客户端连接到我们的服务器时，我们就开始监听收到的消息。当新消息到达时，我们将它广播给所有连接的客户端
4. `broadcast()`函数是对所有连接客户端进行广播，`send()`函数在其中的每一个客户端上被调用。

这是`Node.js`的魔力！ 当然，我们实现的服务器的功能非常少，仅仅实现了基本的功能，但正如我们将看到的，它能够工作。

#### 实现客户端
接下来，是时候实施我们聊天的客户端了;这也是一个非常小而简单的代码片段，基本上是一个包含一些基本`JavaScript`代码的最少的`HTML`页面。让我们在一个名为`www/index.html`的文件中创建这个页面，如下所示：

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      var ws = new WebSocket('ws://' + window.document.location.host);
      ws.onmessage = function(message) {
        var msgDiv = document.createElement('div');
        msgDiv.innerHTML = message.data;
        document.getElementById('messages').appendChild(msgDiv);
      };
      
      function sendMessage() {
        var message = document.getElementById('msgBox').value;
        ws.send(message);
      }
    </script>
  </head>
  <body>
    Messages:
    <div id='messages'></div>
    <input type='text' placeholder='Send a message' id='msgBox'>
    <input type='button' onclick='sendMessage()' value='Send'>
  </body>
</html>
```

我们创建的HTML页面并不需要太多解释; 它只是一个简单的`Web`页面。 我们使用本地`WebSocket`对象初始化与`Node.js`服务器的连接，然后开始监听来自服务器的消息，并在它们到达时将它们显示在新的`div`元素中。相反，我们使用简单的文本框和按钮来发送消息。

在停止或重新启动聊天服务器时，`WebSocket`连接将关闭，并且不会自动重新连接（如果要实现此则需要使用高级库，例如`Socket.io`）。 这意味着在服务器重新启动后重新刷新浏览器以重新建立连接（或实现重新连接机制，这里我们不会介绍）。

#### 运行和扩展聊天应用程序
我们可以尝试立即运行应用程序; 只需使用以下命令启动服务器即可：

```bash
node app 8080
```

> 要运行这个demo，您需要支持本机`WebSocket`的最新浏览器。这里有一个兼容的浏览器列表： http://caniuse.com/#feat=websockets 

打开浏览器，访问 http://localhost:8080 ：

![](http://oczira72b.bkt.clouddn.com/18-3-6/56502781.jpg)

我们现在要展示的是当我们尝试通过启动多个实例来扩展应用程序时发生的情况。让我们尝试这样做，让我们在另一个端口上启动另一台服务器：

```bash
node app 8081
```

缩放我们的聊天应用程序的理想结果应该是连接到两个不同服务器的两个客户端应该能够交换聊天消息。不幸的是，这不如我们所愿。 我们可以通过打开另一个浏览器选项卡来尝试打开 http://localhost:8081 。

在一个实例上发送聊天消息时，我们在本地广播一条消息，仅将其分发给连接到该特定服务器的客户端。实际上，两台服务器不会互相通话。 我们需要整合它们。

![](http://oczira72b.bkt.clouddn.com/18-3-6/27320700.jpg)

在实际的应用程序中，我们将使用负载平衡器来分配实例中的负载，但对于此演示，我们不会使用它。这使我们能够以确定性的方式访问每台服务器，以验证它与其它实例交互的方式。

### 使用Redis作为消息代理
我们通过引入[Redis](http://redis.io)开始分析最重要的`pub / sub`实现，这是一个非常快速和灵活的键/值存储，也被许多人定义为数据结构服务器。

Redis比消息代理更像是一个数据库；然而，在其众多功能中，有一对专门用于实现集中式发布/订阅模式的命令。
当然，与更先进的面向消息的中间件相比，这种实现非常简单和基本，但这是其受欢迎的主要原因之一。通常，实际上，`Redis`已经在现有基础架构中广泛使用，例如，作为缓存服务器或会话存储；它的速度和灵活性使其成为在分布式系统中共享数据的非常流行的选择。因此，只要项目中出现对发布/订阅代理的需求，最简单直接的选择就是重用`Redis`本身，避免安装和维护专用的消息代理。让我们以一个例子来展示它的功能。

> 这个例子需要安装`Redis`，监听它的默认端口。你可以在这里查看： https://redis.io/topics/quickstart 

我们计划使用`Redis`来作为聊天服务器的消息代理。每个实例都将从其客户端接收到的任何消息发布给代理，并同时订阅来自其他服务器实例的消息。正如我们所看到的，我们架构中的每个服务器都是订阅者和发布者。下图显示了我们想要获得的体系结构的表示形式：

![](http://oczira72b.bkt.clouddn.com/18-3-6/56153519.jpg)

通过查看上图，我们可以总结一条消息的经历如下：

1. 将消息输入到网页的文本框中并发送到聊天服务器的连接实例。
2. 邮件然后发布给代理。
3. 代理将消息分派给所有订阅者，在我们的体系结构中，所有订阅者都是聊天服务器的实例。
4. 在每种情况下，都会将消息分发给所有连接的客户端。

`Redis`允许发布和订阅由字符串标识的频道，例如`chat.nodejs`。它还允许我们使用`glob`风格的模式来定义可能匹配多个频道的订阅，例如`chat.*`。

我们在实践中看看它是如何工作的。让我们通过添加发布/订阅逻辑来修改服务器代码：

```javascript
const WebSocketServer = require('ws').Server;
const redis = require("redis");
const redisSub = redis.createClient();
const redisPub = redis.createClient();

// 静态文件服务器
const server = require('http').createServer(
  require('ecstatic')({root: `${__dirname}/www`})
);

const wss = new WebSocketServer({server: server});
wss.on('connection', ws => {
  console.log('Client connected');
  ws.on('message', msg => {
    console.log(`Message: ${msg}`);
    redisPub.publish('chat_messages', msg);
  });
});

redisSub.subscribe('chat_messages');
redisSub.on('message', (channel, msg) => {
  wss.clients.forEach((client) => {
    client.send(msg);
  });
});

server.listen(process.argv[2] || 8080);
```

我们对原始聊天服务器所做的更改在前面的代码中突出显示；下面来解释其工作原理：

1. 要将我们的`Node.js`应用程序连接到`Redis`服务器，我们使用[redis](https://npmjs.org/package/redis)，它是一个支持所有可用`Redis`命令的完整客户端。 接下来，我们实例化两个不同的连接，一个用于订阅`channel`，另一个用于发布消息。 这在`Redis`中是必需的，因为一旦连接进入用户模式，就只能使用与订阅相关的命令。 这意味着我们需要第二个连接来发布消息。

2. 当从连接的客户端收到新消息时，我们会在`chat_messages`通道中发布消息。我们不直接向客户广播该消息，因为我们所有的服务器订阅了同一个`channel`（我们稍后会看到），所以它会通过`Redis`返回给我们。 对于这个例子的范围来说，这是一个简单而有效的机制。
3. 正如我们所说的，我们的服务器还必须订阅`chat_messages`通道，因此我们注册一个侦听器来接收发布到该通道的所有消息（通过当前服务器或任何其他聊天服务器）。当收到消息时，我们只是将它广播给所有连接到当前`WebSocket`服务器的客户端。

这些少许的改变足以让聊天服务器信息互通。为了证明这一点，我们可以尝试启动我们应用程序的多个实例：

```bash
node app 8080
node app 8081
node app 8082
```

然后，我们可以将多个浏览器的选项卡连接到每个实例，并验证我们发送到一台服务器的消息是否被连接到不同服务器的所有其他客户端成功接收。恭喜！我们只使用发布/订阅模式集成了分布式实时应用程序。

![](http://oczira72b.bkt.clouddn.com/18-3-7/85762682.jpg)

![](http://oczira72b.bkt.clouddn.com/18-3-7/75060663.jpg)

### 使用ØMQ进行点对点发布/订阅
代理的存在可以大大简化消息传递系统的体系结构；但是，在某些情况下，它不是最佳解决方案，例如，当不能接受延时的情况下，扩展复杂的分布式系统时，或者当代理节点失败或发生异常的情况。

#### 介绍ØMQ
如果我们的项目可选择点对点消息交换模式，那最佳解决方案应该是[ØMQ](http://zeromq.org)，也称为`zmq`、`ZeroMQ`或`0MQ`）；我们在本书前面已经提到过这个库。`ØMQ`是一个网络库，提供构建各种消息模式的基本工具。它是低级的，速度非常快，并且具有简约的`API`，但它提供了消息传递系统的所有基本构建模块，例如原子消息，负载平衡，队列等等。它支持许多类型的传输，例如进程内通道（`inproc://`），进程间通信（`ipc://`），使用PGM协议（`pgm://`或`epgm://`）的多播，当然，经典的`TCP`（`tcp://`）。
在`ØMQ`的功能中，我们还可以找到实现发布/订阅模式的工具，这正是我们的例子所需要的。因此，我们现在要做的是从聊天应用程序的体系结构中删除代理（`Redis`），并让各个节点以对等方式进行通信，利用`ØMQ`的发布/订阅套接字。

> `ØMQ`套接字可以被视为类固化网络套接字，它提供了很多方法来帮助实现最常见的消息传递模式。例如，我们可以找到实现发布/订阅，请求/回复或单向通信的套接字。

#### 为聊天设计一个对等体系结构的服务器
当我们从架构中移除代理时，聊天应用程序的每个实例都必须直接连接到其他可用实例，以便接收他们发布的消息。 在ØMQ中，我们有两种专门为此设计的套接字：`PUB`和`SUB`。典型的模式是将`PUB`套接字绑定到一个端口，该端口将开始侦听来自其他`SUB`套接字的订阅。

订阅可以有一个过滤器，指定将传递到`SUB`套接字的消息。该过滤器是一个简单的二进制缓冲区（所以它也可以是一个字符串），它将与消息的开头（这也是一个二进制缓冲区）相匹配。当通过`PUB`套接字发送一条消息时，它将被广播到所有连接的`SUB`套接字，但仅在应用了它们的订阅过滤器之后。仅当使用连接的协议时，过滤器才会应用到发布方，例如`TCP`。

下图显示了应用于我们的分布式聊天服务器体系结构的模式（为简单起见，仅有两个实例）：

![](http://oczira72b.bkt.clouddn.com/18-3-7/11976098.jpg)

> 要运行本节中的示例，您需要在系统上安装本地`ØMQ`二进制文件。 你可以在 http://zeromq.org/intro:get-the-software 找到更多信息。注意：此示例已针对`ØMQ`的`4.0`分支进行了测试。

#### 使用`ØMQ`的`PUB / SUB`套接字
让我们通过修改我们的聊天服务器来看看它是如何工作的：

```javascript
const WebSocketServer = require('ws').Server;
const args = require('minimist')(process.argv.slice(2));
const zmq = require('zmq');

//static file server
const server = require('http').createServer(
  require('ecstatic')({root: `${__dirname}/www`})
);

const pubSocket = zmq.socket('pub');
pubSocket.bind(`tcp://127.0.0.1:${args['pub']}`);

const subSocket = zmq.socket('sub');
const subPorts = [].concat(args['sub']);
subPorts.forEach(p => {
  console.log(`Subscribing to ${p}`);
  subSocket.connect(`tcp://127.0.0.1:${p}`);
});
subSocket.subscribe('chat');

subSocket.on('message', msg => {
  console.log(`From other server: ${msg}`);
  broadcast(msg.toString().split(' ')[1]);
});

const wss = new WebSocketServer({server: server});
wss.on('connection', ws => {
  console.log('Client connected'); 
  ws.on('message', msg => {
    console.log(`Message: ${msg}`);
    broadcast(msg);
    pubSocket.send(`chat ${msg}`);
  });
});

function broadcast(msg) {
  wss.clients.forEach(client => {
    client.send(msg);
  });
}

server.listen(args['http'] || 8080);
```

前面的代码清楚地表明，我们的应用程序的逻辑变得稍微复杂一些；然而，考虑到我们正在实施分布式和点对点的发布/订阅模式，它仍然很简单。让我们看看所有的部分是如何结合在一起的：

1. 我们需要[zmq](https://npmjs.org/package/zmq)，它基本上是`ØMQ`库的`Node.js`版本。我们还需要[minimist](https://npmjs.org/package/minimist)，它是一个命令行参数解析器；我们需要这个能够轻松接受命名参数。
2. 我们立即创建我们的`PUB`套接字并将其绑定到 - `pub`命令行参数中提供的端口。
3. 我们创建`SUB`套接字，并将它连接到应用程序其他实例的`PUB`套接字。目标`PUB`套接字的端口在--`sub`命令行参数中提供（可能有多个）。然后，我们通过提供`chat`作为过滤器来创建实际订阅，这意味着我们只会收到以`chat`开始的消息。
4. 当我们的`WebSocket`接收到新消息时，我们将它广播给所有连接的客户端，但我们也通过`PUB`套接字发布它。 我们使用`chat`作为前缀，然后是空格，因此该消息将作为过滤器发布到所有使用`chat`的订阅者。
5. 我们开始监听到达我们`SUB`套接字的消息，我们对消息做一些简单的解析以删除聊天前缀，然后我们将它广播给所有连接到当前`WebSocket`服务器的客户端。

我们现在已经构建了一个简单的分布式系统，使用点对点发布/订阅模式进行集成！

让我们开始吧，让我们通过确保正确连接它们的`PUB`和`SUB`插槽来启动我们的应用程序的三个实例：

```bash
node app --http 8080 --pub 5000 --sub 5001 --sub 5002
node app --http 8081 --pub 5001 --sub 5000 --sub 5002
node app --http 8082 --pub 5002 --sub 5000 --sub 5001
```

第一个命令将启动一个`HTTP`服务器侦听端口`8080`的实例，同时在端口`5000`上绑定`PUB`套接字，并将`SUB`套接字连接到端口`5001`和`5002`，这是其他两个实例的`PUB`套接字应该侦听的端口。其他两个命令以类似的方式工作。

现在，我们可以看到的第一件事情是，如果与`PUB`套接字对应的端口不可用，`ØMQ`不会崩溃。例如，在第一个命令执行时，端口`5001`和`5002`仍然不可用；但是，`ØMQ`不会引发任何错误。这是因为`ØMQ`具有重连机制，它会自动尝试定期与这些端口建立连接。如果任何节点出现故障或重新启动，此功能特别适用。相同的逻辑适用于`PUB`套接字：如果没有订阅者，它将简单地删除所有消息，但它将继续工作。

此时，我们可以尝试使用浏览器导航到我们启动的任何服务器实例，并验证这些消息是否适当地向所有聊天服务器广播。

![](http://oczira72b.bkt.clouddn.com/18-3-7/85762682.jpg)

在前面的例子中，我们假设了一个静态体系结构，其中实例的数量和地址是事先已知的。我们可以引入一个服务注册表，如前一章所述，动态连接我们的实例。同样重要的是要指出`ØMQ`可以用来实现代理模式。

#### 高性能订阅者
